%pure-parser
%name-prefix="LanCF_"
%locations
%defines
%error-verbose
%parse-param { LanCF_Context* context }
%lex-param { void* scanner  }

%{
    #include <stdio.h>
    #include "Global.h"
    #include "Symbols.h"

    #include "ast_node_global_def_include.h"
    #include "ast_node_types.hpp"
    #include "ast_nodes_impl.hpp"
    #include "ast_nodes_flow.hpp"
    #include "ast_nodes_func.hpp"
    #include "ast_nodes_ops.hpp"
    #include "factory_ast_node_global_def.h"
    #include "LanCF_Context.h"
%}

%union {
    int _int;
    std::string *txt;
    ast_node_global_def* gDef;
    ast_node_global_defList *gDefList;
    ast_node_statement *stmt;
    ast_node_statement_value_expr* stmtExpr;
    ast_node_statementlist *stmtList;
    ast_node_value_expr *valExpr;
    ast_node_lvalue_expr *lvalExpr;
    ast_node_exprlist *exprL;
    ast_node_parlist *parL;
    ast_node_declaration_var *varDecl;
    ast_node_constIntList *constL;
    atype* _atype;
    atype_list* _atype_list;
    decl_end* _decl_end;
    func_decl_end* _func_decl_end;
    init_assignment* _init_assignment;
    parameter_list* _parameter_list;
    parameter_list_intern* _parameter_list_intern;
    param_decl* _param_decl;
    var_decl* _var_decl;
    var_name* _var_name;
    SymbolVar* varSym;
    SymbolFunc* funcSym;

    exprA* _exprA;
    exprB* _exprB;
    exprC* _exprC;
    exprD* _exprD;
    exprE* _exprE;
    assignment* _assignment;
    expr_list* _expr_list;
    symbol_expr* _symbol_expr;
}

%token <_int> ZAHL
%token <txt> NAME PP_INCLUDE

// Andi
%token ADD SUB MUL DIV END
%token CMPL CMPG CMPLE CMPGE CMPEQ CMPNE ASSIGNOP ASSIGNOPG ASSIGNOPP ASSIGNOPPG /* ASSIGN OP(ERATOR) P(OINTER) G(LOBAL) */

// Benny asm_nodes_control_structures
%token WHILE FOR IF ELSE DO VOIDDEF INTDEF INTPDEF INTVECDEF INTVECPDEF INTVECARRDEF KW_RETURN KW_UNSIGNED KW_LONG KW_INT KW_CHAR

// Ewald
%token FUNCTIONDEF FUNCTIONCALL PARLIST PAR PRGM STMTLIST STMT BLOCK TERM FAKT KLAMMER DEFLIST EXPR EXPRLIST
%token ASM PUSH POP IMUL

%token ARROW_RIGHT

%token VIRTUAL STATIC
%token CONST

%nonassoc L_THEN
%nonassoc ELSE

%type <_atype> atype a_none_pointer_type a_cpp_type
%type <_atype_list> template_param_list
%type <_decl_end> decl_end
%type <_func_decl_end> func_decl_end
%type <_init_assignment> init_assignment
%type <_parameter_list> parameter_list
%type <_parameter_list_intern> parameter_list_intern
%type <_param_decl> param_decl
%type <_var_decl> var_decl
%type <_var_name> var_name
%type <_int> array_size

%type <_exprA> exprA
%type <_exprB> exprB
%type <_exprC> exprC
%type <_exprD> exprD
%type <_exprE> exprE
%type <_assignment> assignment
%type <_symbol_expr> symbol_expr
%type <_expr_list> expr_list

%token funcDef BLOCK_START PUBLIC PRIVATE PROTECTED CLASS NAMESPACE STRUCT NS_SEP
%token <txt> BLOCK_END

%{
    #include <iostream>
    #include <sstream>
    #include "LanAB_Context.h"
    #include "LanCF_Context.h"

    using namespace std;

    int LanCF_lex(YYSTYPE* lvalp, YYLTYPE* llocp, void* scanner);

    void LanCF_error(YYLTYPE* locp, LanCF_Context* context, const char* err)
    {
        context->yy_error(err);
    }

    #define scanner context->scanner
%}

%%

datei:      blocklist
;

blocklist:  blocklist block
|           /* empty */
;

block:      namespace_decl
|           class_decl
|           decl
|           include
;

include:    PP_INCLUDE                          {   context->include(*$1); delete $1; }
;

decl:       atype var_name decl_end                 { context->decl($1, $2, $3); }
|           atype NAME NS_SEP var_name decl_end     { context->decl($1, *$2, $4, $5); delete $2; }
;

decl_end:   ';'                                 { $$ = new decl_end(); }
|           '=' init_assignment ';'             { $$ = new decl_end(); $$->_init_assignment = $2; }
|           parameter_list func_decl_end        { $$ = new decl_end(); $$->_parameter_list = $1; $$->_func_decl_end = $2; }
;

init_assignment:    BLOCK_START BLOCK_END       { $$ = new init_assignment(); }
|                   NAME                        { $$ = new init_assignment(); delete $1; }
;

parameter_list:     '(' parameter_list_intern ')'   { $$ = $2; }
|                   '(' ')'                         { $$ = new parameter_list(); }
;

parameter_list_intern:      param_decl                              { $$ = new parameter_list(); $$->push_back($1); }
|                           parameter_list_intern ',' param_decl    { $$ = $1; $$->push_back($3); }
;

param_decl:     var_decl                        { $$ = $1; }
;

var_decl:       atype var_name                  { $$ = new var_decl(); $$->_atype = $1; $$->_var_name = $2; }
;

var_name:       NAME                            { $$ = new var_name(); $$->name = *$1; delete $1; };
|               var_name '[' array_size ']'     { $$ = $1; $$->vector_size.push_back($3); };
;

array_size:     ZAHL                            { $$ = $1; }
|               /* nix */                       { $$ = -1; }
;

func_decl_end:  ';'                                             { $$ = new func_decl_end(); }
|               ':' c_initialise_list BLOCK_START BLOCK_END     { $$ = new func_decl_end(); }
|               BLOCK_START BLOCK_END                           { $$ = new func_decl_end(); }
;

c_initialise_list:  initialise_item
|                   c_initialise_list ',' initialise_item
;

initialise_item:    NAME '(' expr_list ')'
;

class_decl:     class_kw class_name ';'
|               class_kw class_name class_decl_body ';'
|               class_kw class_name ':' class_decl_inheritances class_decl_body ';'
;

class_name:     NAME        { context->class_name($1); delete $1; }
;

class_kw:   CLASS       { context->class_kw(false); }
|           STRUCT      { context->class_kw(true); }
;

class_decl_body:    BLOCK_START { context->block_start(); }
                    BLOCK_END { context->class_decl_body(*$3); delete $3; }
;

class_decl_inheritances:    class_decl_inheritances class_decl_inheritance
|                           class_decl_inheritance
;

class_decl_inheritance: PUBLIC NAME     { context->class_inheritance("public", *$2); delete $2; }
|                       PROTECTED NAME  { context->class_inheritance("protected", *$2); delete $2; }
|                       PRIVATE NAME    { context->class_inheritance("private", *$2); delete $2; }
|                       NAME            { context->class_inheritance("", *$1); delete $1; }
;

namespace_decl:     NAMESPACE NAME BLOCK_START
                    {
                        context->block_start();
                    }
                    BLOCK_END
                    {
                        context->namespace_decl(*$2, *$5);
                        delete $2;
                        delete $5;
                    }
;

atype:	a_none_pointer_type
|       atype '*'                                       { $$ = $1; $$->pointer_level++; }
|       atype '&'                                       { $$ = $1; $$->is_reference = true; }
;

a_none_pointer_type: a_cpp_type
|                    CONST a_cpp_type                   { $$ = $2; }
;

a_cpp_type: NAME                                        { $$ = new atype(); $$->name = *$1; delete $1; }
|           NAME '<' template_param_list '>'            { $$ = new atype(); $$->name = *$1; delete $1; $$->template_params = $3; }
|           NAME NS_SEP a_none_pointer_type             { $$ = $3; $$->namespaces.push_back(*$1); delete $1; }
|           NS_SEP a_none_pointer_type                  { $$ = $2; $$->namespaces.push_back(""); }
;

template_param_list:                                    { $$ = new atype_list(); }
|                   atype                               { $$ = new atype_list(); $$->push_back($1); }
|                   template_param_list ',' atype       { $$ = $1; $$->push_back($3); }
;

exprA:
//                    assignment        { $$ = $1; }
                   exprB             { $$ = $1; }
;

assignment:         exprA '=' exprA    { $$ = new assignment($1, $3); }
;

exprB:              exprB CMPL exprC        { $$ = new expr_op2("<", $1, $3); }
|                   exprB CMPG exprC        { $$ = new expr_op2(">", $1, $3); }
|                   exprB CMPLE exprC       { $$ = new expr_op2("<=", $1, $3); }
|                   exprB CMPGE exprC       { $$ = new expr_op2(">=", $1, $3); }
|                   exprB CMPEQ exprC       { $$ = new expr_op2("==", $1, $3); }
|                   exprB CMPNE exprC       { $$ = new expr_op2("!=", $1, $3); }
|                   exprB '+' exprC         { $$ = new expr_op2("+", $1, $3); }
|                   exprB '-' exprC         { $$ = new expr_op2("-", $1, $3); }
|                   exprC                   { $$ = $1; }
;

exprC:              exprC '*' exprD         { $$ = new expr_op2("*", $1, $3); }
|                   exprC '/' exprD         { $$ = new expr_op2("/", $1, $3); }
|                   exprD                   { $$ = $1; }
;

exprD:              exprE                           { $$ = $1; }
|                   exprD ARROW_RIGHT symbol_expr   { $$ = new expr_addr_op($3); }
;

exprE:              '(' exprA ')'               { $$ = $2; }
|                   ZAHL                        { $$ = new expr_constant_int($1); }
|                   '&' exprE                   { $$ = new expr_addr_op($2); }
|                   symbol_expr                 { $$ = $1; }
;

symbol_expr:        NAME                    { $$ = new symbol_expr(); $$->name = *$1; delete $1; }
|                   NAME '(' expr_list ')'  { $$ = new symbol_expr(); $$->name = *$1; delete $1; $$->_expr_list = $3; }
;

expr_list:          expr_list ',' exprA     { $$ = $1; $$->push_back($3); }
|                   exprA                   { $$ = new expr_list(); $$->push_back($1); }
|                   /* nix */               { $$ = new expr_list(); }
;
