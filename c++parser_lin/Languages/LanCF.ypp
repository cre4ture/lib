%pure-parser
%name-prefix="LanCF_"
%locations
%defines
%error-verbose
%parse-param { LanCF_Context* context }
%lex-param { void* scanner  }

%{
    #include <stdio.h>
    #include "Global.h"
    #include "Symbols.h"

    #include "ast_node_global_def_include.h"
    #include "ast_node_types.hpp"
    #include "ast_nodes_impl.hpp"
    #include "ast_nodes_flow.hpp"
    #include "ast_nodes_func.hpp"
    #include "ast_nodes_ops.hpp"
    #include "factory_ast_node_global_def.h"
    #include "LanCF_Context.h"
%}

%union {
    int _int;
    std::string *txt;
    ast_node_global_def* gDef;
    ast_node_global_defList *gDefList;
    ast_node_statement *stmt;
    ast_node_statement_value_expr* stmtExpr;
    ast_node_statementlist *stmtList;
    ast_node_value_expr *valExpr;
    ast_node_lvalue_expr *lvalExpr;
    ast_node_exprlist *exprL;
    ast_node_parlist *parL;
    ast_node_declaration_var *varDecl;
    ast_node_constIntList *constL;
    atype* _atype;
    atype_list* _atype_list;
    decl_end* _decl_end;
    decl* _decl;
    func_decl_end* _func_decl_end;
    init_assignment* _init_assignment;
    parameter_list* _parameter_list;
    parameter_list_intern* _parameter_list_intern;
    param_decl* _param_decl;
    var_decl* _var_decl;
    var_name* _var_name;
    class_kw _class_kw;
    SymbolVar* varSym;
    SymbolFunc* funcSym;
}

%token <_int> ZAHL
%token <txt> NAME PP_INCLUDE

// Andi
%token ADD SUB MUL DIV END
%token CMPL CMPG CMPLE CMPGE CMPEQ CMPNE ASSIGNOP ASSIGNOPG ASSIGNOPP ASSIGNOPPG /* ASSIGN OP(ERATOR) P(OINTER) G(LOBAL) */

// Benny asm_nodes_control_structures
%token WHILE FOR IF ELSE DO VOIDDEF INTDEF INTPDEF INTVECDEF INTVECPDEF INTVECARRDEF KW_RETURN KW_UNSIGNED KW_LONG KW_INT KW_CHAR

// Ewald
%token FUNCTIONDEF FUNCTIONCALL PARLIST PAR PRGM STMTLIST STMT BLOCK TERM FAKT KLAMMER DEFLIST EXPR EXPRLIST
%token ASM PUSH POP IMUL


%nonassoc L_THEN
%nonassoc ELSE

%type <_atype> atype a_none_pointer_type a_cpp_type
%type <_atype_list> template_param_list
%type <_decl_end> decl_end
%type <_decl> decl
%type <_func_decl_end> func_decl_end
%type <_init_assignment> init_assignment
%type <_parameter_list> parameter_list
%type <_parameter_list_intern> parameter_list_intern
%type <_param_decl> param_decl
%type <_var_decl> var_decl
%type <_var_name> var_name
%type <_int> array_size
%type <_class_kw> class_kw

%token funcDef BLOCK_START PUBLIC PRIVATE PROTECTED CLASS NAMESPACE STRUCT NS_SEP
%token <txt> BLOCK_END

%{
    #include <iostream>
    #include <sstream>
    #include "LanAB_Context.h"
    #include "LanCF_Context.h"

    using namespace std;

    int LanCF_lex(YYSTYPE* lvalp, YYLTYPE* llocp, void* scanner);

    void LanCF_error(YYLTYPE* locp, LanCF_Context* context, const char* err)
    {
        context->yy_error(err);
    }

    #define scanner context->scanner
%}

%%

datei:      blocklist
;

blocklist:  blocklist block
|           /* empty */
;

block:      namespace_decl
|           class_decl
|           decl
|           include
;

include:    PP_INCLUDE
;

decl:       atype NAME decl_end                 { $$ = new decl(); $$->_type = $1; $$->name = *$2; delete $2; $$->_decl_end = $3; }
|           atype NAME NS_SEP NAME decl_end     { $$ = new decl(); $$->_type = $1; $$->namespaces.push_back(*$2); delete $2; $$->name = *$4; delete $4; $$->_decl_end = $5; }
;

decl_end:   ';'                                 { $$ = new decl_end(); }
|           '=' init_assignment ';'             { $$ = new decl_end(); $$->_init_assignment = $2; }
|           parameter_list func_decl_end        { $$ = new decl_end(); $$->_parameter_list = $1; $$->_func_decl_end = $2; }
;

init_assignment:    BLOCK_START BLOCK_END       { $$ = new init_assignment(); }
;

parameter_list:     '(' parameter_list_intern ')'   { $$ = $2; }
|                   '(' ')'                         { $$ = new parameter_list(); }
;

parameter_list_intern:      param_decl                              { $$ = new parameter_list(); $$->push_back($1); }
|                           parameter_list_intern ',' param_decl    { $$ = $1; $$->push_back($3); }
;

param_decl:     var_decl                        { $$ = $1; }
;

var_decl:       atype var_name                  { $$ = new var_decl(); $$->_atype = $1; $$->_var_name = $2; }
;

var_name:       NAME                            { $$ = new var_name(); $$->name = *$1; delete $1; };
|               var_name '[' array_size ']'     { $$ = $1; $$->vector_size.push_back($3); };
;

array_size:     ZAHL                            { $$ = $1; }
|               /* nix */                       { $$ = 0; }
;

func_decl_end:  ';'                             { $$ = new func_decl_end(); }
|               BLOCK_START BLOCK_END           { $$ = new func_decl_end(); }
;

class_decl:     class_kw class_name ';'
|               class_kw class_name class_decl_body ';'
|               class_kw class_name ':' class_decl_inheritances class_decl_body ';'
;

class_name:     NAME        { context->class_name($1); delete $1; }
;

class_kw:       CLASS       { $$ = ckw_class; }
|               STRUCT      { $$ = ckw_struct; }
;

class_decl_body:    BLOCK_START { context->block_start(); }
                    BLOCK_END { context->class_decl_body(*$3); delete $3; }
;

class_decl_inheritances:    class_decl_inheritances class_decl_inheritance
|                           class_decl_inheritance
;

class_decl_inheritance: PUBLIC NAME     { context->class_inheritance("public", *$2); delete $2; }
|                       PROTECTED NAME  { context->class_inheritance("protected", *$2); delete $2; }
|                       PRIVATE NAME    { context->class_inheritance("private", *$2); delete $2; }
|                       NAME            { context->class_inheritance("", *$1); delete $1; }
;

namespace_decl:     NAMESPACE NAME BLOCK_START
                    {
                        context->block_start();
                    }
                    BLOCK_END
                    {
                        context->namespace_decl(*$2, *$5);
                        delete $2;
                        delete $5;
                    }
;

atype:	a_none_pointer_type
|       atype '*'                                       { $$ = $1; $$->pointer_level++; }
|       atype '&'                                       { $$ = $1; $$->is_reference = true; }
;

a_none_pointer_type: a_cpp_type
;

a_cpp_type: NAME                                        { $$ = new atype(); $$->name = *$1; delete $1; }
|           NAME '<' template_param_list '>'            { $$ = new atype(); $$->name = *$1; delete $1; $$->template_params = $3; }
|           NAME NS_SEP a_none_pointer_type             { $$ = $3; $$->namespaces.push_back(*$1); delete $1; }
|           NS_SEP a_none_pointer_type                  { $$ = $2; $$->namespaces.push_back(""); }
;

template_param_list:                                    { $$ = new atype_list(); }
|                   atype                               { $$ = new atype_list(); $$->push_back($1); }
|                   template_param_list ',' atype       { $$ = $1; $$->push_back($3); }
;
